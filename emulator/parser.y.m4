/* $Id: parser.y.m4,v 1.14 1994/05/19 00:03:19 secher Exp $ */

/* Note: This incarnation of parser.y was generated by M4. This causes a
 * number of blank lines before the program text. Just in case you wondered.
 */

define(m4_const,`TOKEN_$1 LPAR bam_const RPAR
	  { Instr_Term($1,const_term);
	  }')

define(m4_functor,`TOKEN_$1 LPAR bam_functor RPAR
	  { Instr_Functor($1,ConstFunctor(name,arity));
	  }')

define(m4_index,`TOKEN_$1 LPAR NUMBER
	  { index1 = atoi(yytext);
	    Instr_Index($1,Bindex(index1));
	  } RPAR')

define(m4_index_binding,`TOKEN_$1 LPAR NUMBER
	  { index1 = atoi(yytext);
	    Instr_Index($1,Bindex(index1));
	  } COMMA bam_binding RPAR')

define(m4_index_const,`TOKEN_$1 LPAR NUMBER
	  { index1 = atoi(yytext);
	  } COMMA bam_const
	  { Instr_Index_Term($1,Bindex(index1),const_term);
	  } RPAR')

define(m4_index_const_label_label,`TOKEN_$1 LPAR NUMBER
	  { index1 = atoi(yytext);
	  } COMMA bam_const COMMA label_dest
	  { label1 = label;
	  } COMMA label_dest RPAR
	  { label2 = label;
	    Instr_Index_Term_Label_Label($1,
		Bindex(index1),const_term,label1,label2);
	  }')

define(m4_index_constlist,`TOKEN_$1 LPAR NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { tablesize = atoi(yytext);
	    Instr_Index_Size($1,Bindex(index1),tablesize);
	  } DASH LHPAR bam_const_table RHPAR
	  { sort_switch_table(tablesize);
	  } RPAR')

define(m4_index_functor_label_level_offset_index,`TOKEN_$1 LPAR NUMBER
	  { index1 = atoi(yytext);
	  } COMMA bam_functor COMMA label_dest COMMA NUMBER
	  { number = atoi(yytext);
	  } COMMA NUMBER
	  { offset1 = atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	    Instr_Index_Functor_Label_Level_Offset_Index($1,
		Bindex(index1),ConstFunctor(name,arity),label,number,
		offset1,Bindex(index2));
	  } RPAR')

define(m4_index_functor_label_offset_index,`TOKEN_$1 LPAR NUMBER
	  { index1 = atoi(yytext);
	  } COMMA bam_functor COMMA label_dest COMMA NUMBER
	  { offset1 = atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	    Instr_Index_Functor_Label_Offset_Index($1,
		Bindex(index1),ConstFunctor(name,arity),
		label,offset1,Bindex(index2));
	  } RPAR')

define(m4_index_functorlist,`TOKEN_$1 LPAR NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { tablesize = atoi(yytext);
	    Instr_Index_Size($1,Bindex(index1),tablesize);
	  } DASH LHPAR bam_functor_table RHPAR
	  { sort_switch_table(tablesize);
	  } RPAR')

define(m4_index_index,`TOKEN_$1 LPAR NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	    Instr_Index_Index($1,Bindex(index1),Bindex(index2));
	  } RPAR')

define(m4_index_index_label_label,`TOKEN_$1 LPAR NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	  } COMMA label_dest
	  { label1 = label;
	  } COMMA label_dest RPAR
	  { label2 = label;
	    Instr_Index_Index_Label_Label($1,
		Bindex(index1),Bindex(index2),label1,label2);
	  }')

define(m4_index_index_offset,`TOKEN_$1 LPAR NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	  } COMMA NUMBER
	  { offset1 = atoi(yytext);
	    Instr_Index_Index_Offset($1,Bindex(index1),Bindex(index2),offset1);
	  } RPAR')

define(m4_index_label,`TOKEN_$1 LPAR NUMBER
	  { index1 = atoi(yytext);
	  } COMMA label_dest
	  { label1 = label;
	    Instr_Index_Label($1,Bindex(index1),label1);
	  } RPAR')

define(m4_index_labels_5,`TOKEN_$1 LPAR NUMBER
	  { index1 = atoi(yytext);
	  } COMMA label_dest
	  { label1 = label;
          } COMMA label_dest
	  { label2 = label;
	  } COMMA label_dest
	  { label3 = label;
	  } COMMA label_dest
	  { label4 = label;
	  } COMMA label_dest
          { label5 = label;
	    Instr_Index_Labels_5($1,Bindex(index1),
		label1,label2,label3,label4,label5);
	  } RPAR')

define(m4_index_label_arity,`TOKEN_$1 LPAR NUMBER
	  { index1 = atoi(yytext);
	  } COMMA label_dest COMMA NUMBER
	  { arity = atoi(yytext);
	    Instr_Index_Label_Size($1,Bindex(index1),label,arity);
	  } RPAR')

define(m4_index_label_constlist,`TOKEN_$1 LPAR NUMBER
	  { index1 = atoi(yytext);
	  } COMMA label_dest
	  { label1 = label;
	  } COMMA NUMBER
	  { tablesize = atoi(yytext);
	    Instr_Index_Label_Size($1,Bindex(index1),label1,tablesize);
	  } DASH LHPAR bam_const_table RHPAR
	  { sort_switch_table(tablesize);
	  } RPAR')

define(m4_index_label_index,`TOKEN_$1 LPAR NUMBER
	  { index1 = atoi(yytext);
	  } COMMA label_dest COMMA NUMBER
	  { index2 = atoi(yytext);
	    Instr_Index_Label_Index($1,Bindex(index1),label,Bindex(index2));
	  } RPAR')

define(m4_index_label_label,`TOKEN_$1 LPAR NUMBER
	  { index1 = atoi(yytext);
	  } COMMA label_dest
	  { label1 = label;
	  } COMMA label_dest
	  { label2 = label;
	    Instr_Index_Label_Label($1,Bindex(index1),label1,label2);
	  } RPAR')

define(m4_index_label_level_index,`TOKEN_$1 LPAR NUMBER
	  { index1 = atoi(yytext);
	  } COMMA label_dest COMMA NUMBER
	  { number = atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	    Instr_Index_Label_Level_Index($1,
		Bindex(index1),label,number,Bindex(index2));
	  } RPAR')

define(m4_index_offset,`TOKEN_$1 LPAR NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { offset1 = atoi(yytext);
	    Instr_Index_Offset($1,Bindex(index1),offset1);
	  } RPAR')

define(m4_index_offset_const,`TOKEN_$1 LPAR NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { offset1 = atoi(yytext);
	  } COMMA bam_const RPAR
	  { Instr_Index_Offset_Term($1,Bindex(index1),offset1,const_term);
	  }')

define(m4_index_offset_functor_label_level_offset_index,`TOKEN_$1 LPAR NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { offset1 = atoi(yytext);
	  } COMMA bam_functor COMMA label_dest COMMA NUMBER
	  { number = atoi(yytext);
	  } COMMA NUMBER
	  { offset2 = atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	    Instr_Index_Offset_Functor_Label_Level_Offset_Index($1,
		Bindex(index1),offset1,ConstFunctor(name,arity),
		label,number,offset2,Bindex(index2));
	  } RPAR')

define(m4_index_offset_functor_label_offset_index,`TOKEN_$1 LPAR NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { offset1 = atoi(yytext);
	  } COMMA bam_functor COMMA label_dest COMMA NUMBER
	  { offset2 = atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	    Instr_Index_Offset_Functor_Label_Offset_Index($1,
		Bindex(index1),offset1,ConstFunctor(name,arity),
		label,offset2,Bindex(index2));
	  } RPAR')

define(m4_index_offset_label_index,`TOKEN_$1 LPAR NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { offset1 = atoi(yytext);
	  } COMMA label_dest COMMA NUMBER
	  { index2 = atoi(yytext);
	    Instr_Index_Offset_Label_Index($1,
		Bindex(index1),offset1,label,Bindex(index2));
	  } RPAR')

define(m4_index_offset_label_level_index,`TOKEN_$1 LPAR NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { offset1 = atoi(yytext);
	  } COMMA label_dest COMMA NUMBER
	  { number = atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	    Instr_Index_Offset_Label_Level_Index($1,
		Bindex(index1),offset1,label,number,Bindex(index2));
	  } RPAR')

define(m4_indices_3,`TOKEN_$1 LPAR NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	  } COMMA NUMBER
	  { index3 = atoi(yytext);
	    Instr_Indices_3($1,Bindex(index1),Bindex(index2),Bindex(index3));
	  } RPAR')

define(m4_label,`TOKEN_$1 LPAR label_dest RPAR
	  { Instr_Label($1,label);
	  }')

define(m4_label_arity,`TOKEN_$1 LPAR label_dest COMMA NUMBER
	  { arity = atoi(yytext);
	    Instr_Label_Size($1,label,arity);
	  } RPAR')

define(m4_label_arity_live,`TOKEN_$1 LPAR label_dest COMMA NUMBER
	  { arity = atoi(yytext);
	  } COMMA NUMBER
	  { bitmax = atoi(yytext);
	    Instr_Label_Size($1,label,arity);
	    bitmask = 0;
	    bitmask_offset = 0;
	  } DASH LHPAR bam_integer_set RHPAR RPAR')

define(m4_label_index_binding,`TOKEN_$1 LPAR label_dest COMMA NUMBER
	  { index1 = atoi(yytext);
	    Instr_Label_Index($1,label,Bindex(index1));
	  } COMMA bam_binding RPAR')

define(m4_label_label,`TOKEN_$1 LPAR label_dest
	  { label1 = label;
	  } COMMA label_dest RPAR
	  { label2 = label;
	    Instr_Label_Label($1,label1,label2);
	  }')

define(m4_label_live,`TOKEN_$1 LPAR label_dest COMMA NUMBER
	  { bitmax = atoi(yytext);
	    Instr_Label($1,label);
	    bitmask = 0;
	    bitmask_offset = 0;
	  } DASH LHPAR bam_integer_set RHPAR RPAR')

define(m4_level_label,`TOKEN_$1 LPAR NUMBER
	  { number = atoi(yytext);
	  } COMMA label_dest RPAR
	  { Instr_Level_Label($1,number,label);
	  }')

define(m4_none,`TOKEN_$1 { Instr_None($1); }')

define(m4_offset,`TOKEN_$1 LPAR NUMBER
	  { offset1 = atoi(yytext);
	    Instr_Offset($1,offset1);
	  } RPAR')

define(m4_pred,`TOKEN_$1 LPAR bam_functor RPAR
	  { Instr_Pred($1,GetPred(fname,arity));
	  }')

define(m4_pred_live,`TOKEN_$1 LPAR bam_functor COMMA NUMBER
	  { bitmax = atoi(yytext);
	    Instr_Pred($1,GetPred(fname,arity));
	    bitmask = 0;
	    bitmask_offset = 0;
	  } DASH LHPAR bam_integer_set RHPAR RPAR')

define(m4_size,`TOKEN_$1 LPAR NUMBER
	  { size = atoi(yytext);
	    Instr_Size($1,size);
	  } RPAR')

define(m4_fd_instr,`{ fd_add_instr($1); }')

define(m4_fd_const,`{ fd_add_const($1); }')

undefine(`define')
%{

#include <stdio.h>
#include <string.h>
#include "include.h"
#include "term.h"
#include "error.h"
#include "instructions.h"
#include "tree.h"
#include "config.h"
#include "predicate.h"
#include "exstate.h"
#include "storage.h"
#include "code.h"
#include "names.h"

#include "encodeinstr.h"
#include "instrdefs.h"
#include "fd_instr.h"
#include "fd.h"

#include "bam.h"

#define BITMASKBITS TADBITS
#define BitMaskWords(m)	(((m) + (BITMASKBITS-1)) / BITMASKBITS)

static char name[MAXATOMLEN];
static char pname[MAXATOMLEN];
static int abs_level;
static int arity;
static int parity;
static int ext;
static int size;
static int number;
static double fnumber;
static int index1;
static int index2;
static int index3;
static int offset1;
static int offset2;
static int label;
static int label1;
static int label2;
static int label3;
static int label4;
static int label5;
static int label6;
static int label7;
static int tablesize;
static uword bitmask;
static int bitmax;
static int bitmask_offset;
static Term const_term;
static Term fname;

/* Used by get_record and put_record... */
static int hv,features;
static Term *tbl;

#ifdef BAM
static bam_typed_type type_code;
#endif

int verbose = 0; 

static int yyerror();

/*
#define YYDEBUG 1
*/

/* Defined by (f)lex: */
extern int yylex PROTO((void));
extern char *yytext;
extern FILE *yyin;

#define yyparse parse

%}


%token TOKEN_SWITCH_ON_TERM TOKEN_TRY_SINGLE TOKEN_TRY TOKEN_RETRY
%token TOKEN_TRUST TOKEN_GUARD_COND TOKEN_GUARD_COMMIT
%token TOKEN_GUARD_WAIT TOKEN_GUARD_UNORDER TOKEN_GUARD_ORDER TOKEN_GUARD_UNIT
%token TOKEN_GUARD_CUT TOKEN_CALL
%token TOKEN_ALLOCATE TOKEN_DEALLOCATE TOKEN_META_CALL TOKEN_EXTERN_EXECUTE
%token TOKEN_EXECUTE TOKEN_DEALLOC_EXECUTE TOKEN_EXTERN_CALL 
%token TOKEN_CALL_APPLY TOKEN_EXECUTE_APPLY TOKEN_DEALLOC_EXECUTE_APPLY
%token TOKEN_PROCEED TOKEN_DEALLOC_PROCEED TOKEN_FAIL TOKEN_GET_X_VARIABLE
%token TOKEN_GET_Y_VARIABLE TOKEN_GET2_Y_VARIABLE TOKEN_GET3_Y_VARIABLE
%token TOKEN_GET4_Y_VARIABLE TOKEN_GET5_Y_VARIABLE TOKEN_GET_X_VALUE
%token TOKEN_GET_Y_VALUE TOKEN_GET_CONSTANT TOKEN_GET_NIL
%token TOKEN_GET_STRUCTURE TOKEN_GET_LIST TOKEN_GET_LIST_X0
%token TOKEN_GET_NIL_X0 TOKEN_GET_STRUCTURE_X0 TOKEN_GET_CONSTANT_X0
%token TOKEN_GET_ABSTRACTION
%token TOKEN_PUT_X_VOID TOKEN_PUT_Y_VOID TOKEN_PUT_X_VARIABLE
%token TOKEN_PUT_Y_VARIABLE TOKEN_PUT_X_VALUE TOKEN_PUT_Y_VALUE
%token TOKEN_PUT2_Y_VALUE TOKEN_PUT3_Y_VALUE TOKEN_PUT4_Y_VALUE
%token TOKEN_PUT5_Y_VALUE TOKEN_PUT_CONSTANT TOKEN_PUT_NIL
%token TOKEN_PUT_STRUCTURE TOKEN_PUT_LIST TOKEN_UNIFY_VOID
%token TOKEN_PUT_ABSTRACTION
%token TOKEN_UNIFY_Y_VARIABLE TOKEN_UNIFY_X_VARIABLE
%token TOKEN_UNIFY_X_VALUE TOKEN_UNIFY_Y_VALUE TOKEN_UNIFY_CONSTANT
%token TOKEN_UNIFY_NIL TOKEN_UNIFY_LIST TOKEN_UNIFY_STRUCTURE
%token TOKEN_SWITCH_ON_CONSTANT TOKEN_SWITCH_ON_STRUCTURE TOKEN_SEND3
%token TOKEN_SUSPEND_FLAT TOKEN_ATOM_SWITCH
%token TOKEN_FAIL_DEC TOKEN_LOAD_NIL TOKEN_LOAD_ATOM TOKEN_LOAD_INTEGER
%token TOKEN_READ_CAR TOKEN_READ_CDR TOKEN_READ_ARG TOKEN_SET_REG_REG
%token TOKEN_SET_REG_YVAR TOKEN_SET_YVAR_REG TOKEN_TERM_SWITCH 
%token TOKEN_ATOM_WITH_ELSE_SWITCH TOKEN_ATOM_WITH_ATOM_ELSE_SWITCH
%token TOKEN_ATOM_TYPE TOKEN_ATOM_TYPE_WITH_ELSE
%token TOKEN_KNOWN_ATOM_SWITCH TOKEN_KNOWN_ATOM_WITH_ATOM_ELSE_SWITCH
%token TOKEN_INTEGER_SWITCH TOKEN_INTEGER_WITH_ELSE_SWITCH
%token TOKEN_INTEGER_WITH_INTEGER_ELSE_SWITCH TOKEN_INTEGER_TYPE
%token TOKEN_INTEGER_TYPE_WITH_ELSE TOKEN_KNOWN_INTEGER_SWITCH
%token TOKEN_KNOWN_INTEGER_WITH_INTEGER_ELSE_SWITCH TOKEN_LIST_SWITCH
%token TOKEN_LIST_TYPE_WITH_ELSE TOKEN_STRUCT_TYPE
%token TOKEN_STRUCT_TYPE_WITH_ELSE TOKEN_KNOWN_FUNCTOR_SWITCH
%token TOKEN_KNOWN_FUNCTOR_WITH_FUNCTOR_ELSE_SWITCH
%token TOKEN_INT_COMPARE_REG_REG TOKEN_INT_COMPARE_REG_INT
%token TOKEN_EQ_REG_REG TOKEN_MATCH_REG_REG TOKEN_MATCH_REG_REG_OFF
%token TOKEN_MATCH_REG_ATOM TOKEN_MATCH_REG_OFF_ATOM
%token TOKEN_MATCH_REG_INTEGER TOKEN_MATCH_REG_OFF_INTEGER
%token TOKEN_MATCH_REG_NIL TOKEN_MATCH_REG_OFF_NIL TOKEN_MATCH_REG_YVAR
%token TOKEN_MATCH_YVAR_YVAR TOKEN_MATCH_YVAR_REG_OFF
%token TOKEN_MATCH_REG_H_LIST TOKEN_MATCH_YVAR_H_LIST
%token TOKEN_MATCH_REG_H_STRUCT TOKEN_MATCH_YVAR_H_STRUCT
%token TOKEN_MATCH_REG_STRUCT TOKEN_MATCH_REG_STRUCT_LEVEL
%token TOKEN_MATCH_REG_OFF_STRUCT TOKEN_MATCH_REG_OFF_STRUCT_LEVEL
%token TOKEN_MATCH_YVAR_STRUCT TOKEN_MATCH_YVAR_STRUCT_LEVEL
%token TOKEN_MATCH_REG_LIST_CAR TOKEN_MATCH_REG_LIST_CAR_LEVEL
%token TOKEN_MATCH_REG_OFF_LIST_CAR TOKEN_MATCH_REG_OFF_LIST_CAR_LEVEL
%token TOKEN_MATCH_YVAR_LIST_CAR TOKEN_MATCH_YVAR_LIST_CAR_LEVEL
%token TOKEN_MATCH_REG_LIST_CDR TOKEN_MATCH_REG_LIST_CDR_LEVEL
%token TOKEN_MATCH_REG_OFF_LIST_CDR TOKEN_MATCH_REG_OFF_LIST_CDR_LEVEL
%token TOKEN_MATCH_YVAR_LIST_CDR TOKEN_MATCH_YVAR_LIST_CDR_LEVEL
%token TOKEN_PUSH_LIST_IMM TOKEN_PUSH_LIST TOKEN_PUSH_STRUCTURE_IMM
%token TOKEN_PUSH_STRUCTURE TOKEN_PUSH_NIL TOKEN_PUSH_REG
%token TOKEN_PUSH_YVAR TOKEN_PUSH_VOID TOKEN_SET_REG_H_AND_PUSH_VOID
%token TOKEN_SET_YVAR_H_AND_PUSH_VOID TOKEN_PUSH_INTEGER TOKEN_PUSH_FUNCTOR
%token TOKEN_SET_REG_AND_YVAR_H_AND_PUSH_VOID TOKEN_PUSH_ATOM 
%token TOKEN_SET_REG_H TOKEN_SET_YVAR_H TOKEN_BTRY TOKEN_BTRUST
%token TOKEN_TEST_TRY TOKEN_TEST_TRUST TOKEN_S_TRY TOKEN_S_TRUST
%token TOKEN_BACK TOKEN_GEN_TRY TOKEN_GEN_TRUST TOKEN_BEXECUTE_SIMPLE
%token TOKEN_BEXECUTE TOKEN_BCALL TOKEN_JUMP_GC_AND_DUMP_CONT
%token TOKEN_JUMP_GC TOKEN_JUMP TOKEN_BPROCEED_SIMPLE TOKEN_BPROCEED
%token TOKEN_CREATE_CONT TOKEN_TEST_LEVEL TOKEN_CONSTRAINT_STACK_TEST
%token TOKEN_JUMP_ON_NONEMPTY_CONSTRAINT_STACK TOKEN_ALIAS_CHECK
%token TOKEN_ALIAS_CHECK_REG TOKEN_FAIL_ON_ALIAS TOKEN_CHOICE_QUIET_CUT
%token TOKEN_SUSPEND_LONE_VAR TOKEN_BSUSPEND TOKEN_SUSPEND_WITHOUT_REG
%token TOKEN_CREATE_GUARD TOKEN_FLAT_QUIET_CUT TOKEN_FLAT_QUIET_COMMIT
%token TOKEN_FLAT_NOISY_WAIT TOKEN_SHORTCUT_QUIET_CUT
%token TOKEN_SHORTCUT_QUIET_COMMIT TOKEN_SHORTCUT_NOISY_WAIT
%token TOKEN_DEEP_QUIET_CUT TOKEN_DEEP_QUIET_COMMIT
%token TOKEN_DEEP_NOISY_WAIT

%token PREDICATE ATOMNAME NEWLINE LPAR RPAR LHPAR RHPAR
%token COMMA DASH SLASH LABEL LABELTAG NUMBER FLOAT END
%token PLABEL CONSTANT LIST STRUCT TYPED INTEGER ATOM
%token FUNCTOR REG VOID LABELED 

%token TOKEN_GET_RECORD
%token TOKEN_PUT_RECORD

%token FD_code_T FD_const_T
%token FD_max_elem_T FD_add_T FD_sub_T FD_mult_T FD_divd_T FD_divu_T FD_mod_T
%token FD_val_T FD_val_0_T FD_val_1_T FD_val_2_T 
%token FD_min_T FD_max_T FD_dom_min_T FD_dom_max_T
%token FD_dom_min_0_T FD_dom_max_0_T FD_dom_min_1_T 
%token FD_dom_max_1_T FD_dom_min_2_T FD_dom_max_2_T
%token FD_dom_T FD_dom_0_T FD_dom_1_T FD_dom_2_T 
%token FD_range_T FD_outer_range_T FD_setadd_T FD_setsub_T 
%token FD_setmod_T FD_compl_T FD_union_T FD_inter_T
%token FD_check_T FD_label_T
%token FD_element_i_T FD_element_x_T




%%

definitions: /* empty */

	| definitions
	  END
	  { return(0);
	  }

	| definitions
	  PREDICATE LPAR ATOMNAME
	  { strcpy(pname, yytext);
	  } SLASH NUMBER 
	  { parity = atoi(yytext); 
	    Define_Predicate(pname,parity);
	  } code RPAR
          { End_Definition;
            if(verbose)
    		printf("{ %s/%d defined }\n",pname,parity);
	  }
        | definitions
	  PREDICATE LPAR NUMBER
          { abs_level = atoi(yytext);
          } SLASH NUMBER
	  { parity = atoi(yytext);
	  } SLASH NUMBER
	  { ext = atoi(yytext);
            Define_Abstraction(abs_level,parity,ext);
	  } code RPAR
          { End_Definition;
            if(verbose)
    		printf("{ abstraction %d defined }\n", abs_level);
	  }
;

code:	  /* empty */
	| code instruction
;	  

instruction:
	  TOKEN_SWITCH_ON_TERM LPAR NUMBER
	  { label1 = atoi(yytext);
          } COMMA NUMBER
	  { label2 = atoi(yytext);
	  } COMMA NUMBER
	  { label3 = atoi(yytext);
	  } COMMA NUMBER  
	  { label4 = atoi(yytext);
	  } COMMA NUMBER
          { label5 = atoi(yytext);
	  } COMMA NUMBER
          { label6 = atoi(yytext);
	  } COMMA NUMBER
          { label7 = atoi(yytext);
          } RPAR
          { Instr_Labels_7(SWITCH_ON_TERM,label1,label2,label3,
			   label4,label5,label6,label7);
	  }
	| TOKEN_TRY_SINGLE LPAR NUMBER
	  { label1 = atoi(yytext);
          } RPAR
	  { Instr_Label(TRY_SINGLE,label1);
          }
	| TOKEN_TRY LPAR NUMBER
	  { label = atoi(yytext);
          } RPAR
	  { Instr_Label(TRY,label);
          }
	| TOKEN_RETRY LPAR NUMBER
	  { label = atoi(yytext);
          } RPAR
	  { Instr_Label(RETRY,label);
          }
	| TOKEN_TRUST LPAR NUMBER
	  { label = atoi(yytext);
          } RPAR
	  { Instr_Label(TRUST,label);
          }
        | TOKEN_GUARD_UNORDER LPAR NUMBER
          { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	  } COMMA NUMBER 
          { index3 = atoi(yytext);
	  } RPAR
	  { Instr_Indices_3(GUARD_UNORDER,index1,index2,index3);
          }
        | TOKEN_GUARD_ORDER LPAR NUMBER
          { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	  } COMMA NUMBER 
          { index3 = atoi(yytext);
	  } RPAR
	  { Instr_Indices_3(GUARD_ORDER,index1,index2,index3);
          }
        | TOKEN_GUARD_UNIT LPAR NUMBER
          { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	  } RPAR
	  { Instr_Index_Index(GUARD_UNIT,index1,index2);
          }
	| TOKEN_GUARD_COND 
	  { Instr_None(GUARD_COND);
	  }
	| TOKEN_GUARD_COMMIT
	  { Instr_None(GUARD_COMMIT);
	  }
	| TOKEN_GUARD_WAIT
	  { Instr_None(GUARD_WAIT)
	  }
        | TOKEN_GUARD_CUT 
	  { Instr_None(GUARD_CUT);
	  }
	| TOKEN_ALLOCATE LPAR NUMBER 
          { size = atoi(yytext);
	  } RPAR
          { Instr_Size(ALLOCATE,size);
          }
	| TOKEN_DEALLOCATE
	  { Instr_None(DEALLOCATE);
	  }
	| TOKEN_META_CALL LPAR NUMBER
	  { index1 = atoi(yytext);
	  } RPAR
	  { Instr_Index(META_CALL,index1);
          }
	| TOKEN_CALL LPAR ATOMNAME 
	  { fname = ConstAtom(yytext);
	  } SLASH NUMBER 
	  { arity = atoi(yytext);
          } RPAR
          { Instr_Pred(CALL,GetPred(fname,arity));
	  }
	| TOKEN_CALL LPAR NUMBER 
	  { label = atoi(yytext);
	  } SLASH NUMBER 
	  { arity = atoi(yytext);
          } RPAR
          { Instr_Pred(CALL,GetAbstraction(label));
	  }
	| TOKEN_EXECUTE LPAR ATOMNAME 
	  { fname = ConstAtom(yytext);
	  } SLASH NUMBER 
	  { arity = atoi(yytext);
          } RPAR
	  { Instr_Pred(EXECUTE,GetPred(fname,arity));
          }
	| TOKEN_EXECUTE LPAR NUMBER
	  { label = atoi(yytext);
	  } SLASH NUMBER 
	  { arity = atoi(yytext);
          } RPAR
	  { Instr_Pred(EXECUTE,GetAbstraction(label));
          }
	| TOKEN_DEALLOC_EXECUTE LPAR ATOMNAME 
	  { fname = ConstAtom(yytext);
	  } SLASH NUMBER 
	  { arity = atoi(yytext);
          } RPAR
	  { Instr_Pred(DEALLOC_EXECUTE,GetPred(fname,arity));
          }
	| TOKEN_DEALLOC_EXECUTE LPAR NUMBER 
	  { label = atoi(yytext);
	  } SLASH NUMBER 
	  { arity = atoi(yytext);
          } RPAR
	  { Instr_Pred(DEALLOC_EXECUTE,GetAbstraction(label));
          }
	| TOKEN_EXTERN_CALL LPAR ATOMNAME 
	  { fname = ConstAtom(yytext);
	  } SLASH NUMBER 
	  { arity = atoi(yytext);
          } COMMA ATOMNAME RPAR
          { Instr_Pred(CALL,GetPred(fname,arity));
	  }
	| TOKEN_EXTERN_EXECUTE LPAR ATOMNAME 
	  { fname = ConstAtom(yytext);
	  } SLASH NUMBER 
	  { arity = atoi(yytext);
          } COMMA ATOMNAME RPAR
	  { Instr_Pred(EXECUTE,GetPred(fname,arity));
          }
	| TOKEN_PROCEED 
	  { Instr_None(PROCEED);
	  }
	| TOKEN_DEALLOC_PROCEED 
	  { Instr_None(DEALLOC_PROCEED);
	  }
	| TOKEN_CALL_APPLY LPAR NUMBER
	  { index1 = atoi(yytext);
          } COMMA NUMBER
	  { size = atoi(yytext);
          } RPAR
          { Instr_Index_Size(CALL_APPLY,index1,size);
	  }
	| TOKEN_EXECUTE_APPLY LPAR NUMBER
	  { index1 = atoi(yytext);
          } COMMA NUMBER
	  { size = atoi(yytext);
          } RPAR
          { Instr_Index_Size(EXECUTE_APPLY,index1,size);
	  }
	| TOKEN_DEALLOC_EXECUTE_APPLY LPAR NUMBER
	  { index1 = atoi(yytext);
          } COMMA NUMBER
	  { size = atoi(yytext);
          } RPAR
          { Instr_Index_Size(DEALLOC_EXECUTE_APPLY,index1,size);
	  }
	| TOKEN_FAIL 
	  { Instr_None(FAIL)
	  }
	| TOKEN_GET_X_VARIABLE LPAR NUMBER 
	  { index1 =  atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	  } RPAR
	  { Instr_Index_Index(GET_X_VARIABLE,index1,index2);
          }
	| TOKEN_GET_Y_VARIABLE LPAR NUMBER 
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	  } RPAR  
	  { Instr_Index_Index(GET_Y_VARIABLE,index1,index2);
          }
	| TOKEN_GET2_Y_VARIABLE LPAR NUMBER 
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	    Instr_Index_Index(GET2_Y_VARIABLE,index1,index2);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
          { index2 = atoi(yytext);
	    Next_Index_Index(index1, index2);
	  } RPAR
	| TOKEN_GET3_Y_VARIABLE LPAR NUMBER 
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	    Instr_Index_Index(GET3_Y_VARIABLE,index1,index2);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
          { index2 = atoi(yytext);
	    Next_Index_Index(index1, index2);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
          { index2 = atoi(yytext);
	    Next_Index_Index(index1, index2);
	  } RPAR
	| TOKEN_GET4_Y_VARIABLE LPAR NUMBER 
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	    Instr_Index_Index(GET4_Y_VARIABLE,index1,index2);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
          { index2 = atoi(yytext);
	    Next_Index_Index(index1, index2);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
          { index2 = atoi(yytext);
	    Next_Index_Index(index1, index2);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
          { index2 = atoi(yytext);
	    Next_Index_Index(index1, index2);
	  } RPAR
	| TOKEN_GET5_Y_VARIABLE LPAR NUMBER 
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	    Instr_Index_Index(GET5_Y_VARIABLE,index1,index2);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
          { index2 = atoi(yytext);
	    Next_Index_Index(index1, index2);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
          { index2 = atoi(yytext);
	    Next_Index_Index(index1, index2);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
          { index2 = atoi(yytext);
	    Next_Index_Index(index1, index2);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
          { index2 = atoi(yytext);
	    Next_Index_Index(index1, index2);
	  } RPAR
	| TOKEN_GET_X_VALUE LPAR NUMBER 
	  { index1 =  atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	  } RPAR  
	  { Instr_Index_Index(GET_X_VALUE,index1,index2);
          }
	| TOKEN_GET_Y_VALUE LPAR NUMBER 
	  { index1 =  atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	  } RPAR  
	  { Instr_Index_Index(GET_Y_VALUE,index1,index2);
          }
	| TOKEN_GET_CONSTANT LPAR NUMBER 
	  { const_term = ConstInt(yytext);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } RPAR
          { Instr_Term_Index(GET_CONSTANT,const_term,index1);
          }
	| TOKEN_GET_CONSTANT LPAR FLOAT 
	  { const_term = ConstFlt(yytext);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } RPAR
          { Instr_Term_Index(GET_CONSTANT,const_term,index1);
          }
	| TOKEN_GET_CONSTANT LPAR ATOMNAME
	  { const_term = ConstAtom(yytext);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } RPAR
          { Instr_Term_Index(GET_CONSTANT,const_term,index1);
          }
	| TOKEN_GET_NIL LPAR NUMBER
	  { index1 = atoi(yytext);
	  } RPAR 
          { Instr_Index(GET_NIL,index1);
          }
	| TOKEN_GET_LIST LPAR NUMBER
	  { index1 = atoi(yytext);
	  } RPAR 
          { Instr_Index(GET_LIST,index1);
          }
	| TOKEN_GET_STRUCTURE LPAR ATOMNAME
	  { fname = ConstAtom(yytext);
	  } SLASH NUMBER
	  { arity = atoi(yytext);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } RPAR 
	  { Instr_Functor_Index(GET_STRUCTURE,ConstFunctor(fname,arity),index1);
          }
	| TOKEN_GET_RECORD LPAR ATOMNAME
          { fname = ConstAtom(yytext);
	  } COMMA NUMBER
	  { arity = atoi(yytext);	
	    features = 0;
	    hv = 0;
	    tbl = (Term*)(malloc(arity * sizeof(Term)));
	  } COMMA LHPAR feat_const_list RHPAR COMMA NUMBER
	  { index1 = atoi(yytext);
	  } RPAR 
          { if (features == 0)
	      hv = HashNameArity(Atm(fname),arity);
	   else 
	      hv = hv + (arity -features);
	    Instr_Functor_Index(GET_STRUCTURE,
	      create_functor(hv,fname,features,arity,tbl),index1);
	    free(tbl);
          }
	| TOKEN_GET_NIL_X0
          { Instr_None(GET_NIL_X0);
	  }
    	| TOKEN_GET_LIST_X0
          { Instr_None(GET_LIST_X0);
	  }
	| TOKEN_GET_CONSTANT_X0 LPAR NUMBER 
	  { const_term = ConstInt(yytext);
	  } RPAR
          { Instr_Term(GET_CONSTANT_X0,const_term);
          }
	| TOKEN_GET_CONSTANT_X0 LPAR FLOAT
	  { const_term = ConstFlt(yytext);
	  } RPAR
          { Instr_Term(GET_CONSTANT_X0,const_term);
          }
	| TOKEN_GET_CONSTANT_X0 LPAR ATOMNAME
	  { const_term = ConstAtom(yytext);
	  } RPAR
          { Instr_Term(GET_CONSTANT_X0,const_term);
          }
	| TOKEN_GET_STRUCTURE_X0 LPAR ATOMNAME
	  { fname = ConstAtom(yytext);
	  } SLASH NUMBER
	  { arity = atoi(yytext);
	  } RPAR 
          { Instr_Functor(GET_STRUCTURE_X0,ConstFunctor(fname,arity));
	  }
	| TOKEN_GET_ABSTRACTION LPAR ATOMNAME
	  { fname = ConstAtom(yytext);
	  } SLASH NUMBER 
	  { arity = atoi(yytext);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
          } RPAR
          { Instr_Pred_Index(GET_ABSTRACTION,GetPred(fname,arity),index1);
          }
	| TOKEN_GET_ABSTRACTION LPAR NUMBER
	  { label = atoi(yytext);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } RPAR
          { Instr_Pred_Index(GET_ABSTRACTION,GetAbstraction(label),index1);
          }
	| TOKEN_PUT_X_VOID LPAR NUMBER 
	  { index1 = atoi(yytext);
	  } RPAR  
          { Instr_Index(PUT_X_VOID,index1);
          }
	| TOKEN_PUT_Y_VOID LPAR NUMBER 
	  { index1 = atoi(yytext);
	  } RPAR  
          { Instr_Index(PUT_Y_VOID,index1);
	  }
	| TOKEN_PUT_X_VARIABLE LPAR NUMBER 
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	  } RPAR  
	  { Instr_Index_Index(PUT_X_VARIABLE,index1,index2);
          }
	| TOKEN_PUT_Y_VARIABLE LPAR NUMBER 
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	  } RPAR  
	  { Instr_Index_Index(PUT_Y_VARIABLE,index1,index2);
          }
	| TOKEN_PUT_X_VALUE LPAR NUMBER 
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	  } RPAR  
	  { Instr_Index_Index(PUT_X_VALUE,index1,index2);
          }
	| TOKEN_PUT_Y_VALUE LPAR NUMBER 
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	  } RPAR  
	  { Instr_Index_Index(PUT_Y_VALUE,index1,index2);
          }
	| TOKEN_PUT2_Y_VALUE LPAR NUMBER 
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	    Instr_Index_Index(PUT2_Y_VALUE,index1,index2);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
          { index2 = atoi(yytext);
	    Next_Index_Index(index1, index2);
	  } RPAR
	| TOKEN_PUT3_Y_VALUE LPAR NUMBER 
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	    Instr_Index_Index(PUT3_Y_VALUE,index1,index2);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
          { index2 = atoi(yytext);
	    Next_Index_Index(index1, index2);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
          { index2 = atoi(yytext);
	    Next_Index_Index(index1, index2);
	  } RPAR
	| TOKEN_PUT4_Y_VALUE LPAR NUMBER 
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	    Instr_Index_Index(PUT4_Y_VALUE,index1,index2);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
          { index2 = atoi(yytext);
	    Next_Index_Index(index1, index2);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
          { index2 = atoi(yytext);
	    Next_Index_Index(index1, index2);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
          { index2 = atoi(yytext);
	    Next_Index_Index(index1, index2);
	  } RPAR
	| TOKEN_PUT5_Y_VALUE LPAR NUMBER 
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { index2 = atoi(yytext);
	    Instr_Index_Index(PUT5_Y_VALUE,index1,index2);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
          { index2 = atoi(yytext);
	    Next_Index_Index(index1, index2);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
          { index2 = atoi(yytext);
	    Next_Index_Index(index1, index2);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
          { index2 = atoi(yytext);
	    Next_Index_Index(index1, index2);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
          { index2 = atoi(yytext);
	    Next_Index_Index(index1, index2);
	  } RPAR
	| TOKEN_PUT_CONSTANT LPAR NUMBER
	  { const_term = ConstInt(yytext);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } RPAR 
          { Instr_Term_Index(PUT_CONSTANT,const_term,index1);
          }
	| TOKEN_PUT_CONSTANT LPAR FLOAT
	  { const_term = ConstFlt(yytext);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } RPAR 
          { Instr_Term_Index(PUT_CONSTANT,const_term,index1);
          }
	| TOKEN_PUT_CONSTANT LPAR ATOMNAME
	  { const_term = ConstAtom(yytext);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } RPAR 
          { Instr_Term_Index(PUT_CONSTANT,const_term,index1);
          }
	| TOKEN_PUT_NIL LPAR NUMBER
	  { index1 = atoi(yytext);
	  } RPAR 
          { Instr_Index(PUT_NIL,index1);
          }
	| TOKEN_PUT_STRUCTURE LPAR ATOMNAME
	  { fname = ConstAtom(yytext);
	  } SLASH NUMBER
	  { arity = atoi(yytext);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } RPAR 
          { Instr_Functor_Index(PUT_STRUCTURE,ConstFunctor(fname,arity),index1);
          }
	| TOKEN_PUT_RECORD LPAR ATOMNAME
          { fname = ConstAtom(yytext);
	  } COMMA NUMBER
	  { arity = atoi(yytext);	
	    features = 0;
	    hv = 0;
	    tbl = (Term*)(malloc(arity * sizeof(Term)));
	  } COMMA LHPAR feat_const_list RHPAR COMMA NUMBER
	  { index1 = atoi(yytext);
	  } RPAR 
	  { if (features == 0)
	      hv = HashNameArity(Atm(fname),arity);
	   else 
	      hv = hv + (arity -features);
	    Instr_Functor_Index(PUT_STRUCTURE,
	      create_functor(hv,fname,features,arity,tbl),index1);
	    free(tbl);
          }
	| TOKEN_PUT_LIST LPAR NUMBER
	  { index1 = atoi(yytext);
	  } RPAR 
          { Instr_Index(PUT_LIST,index1);
          }
	| TOKEN_PUT_ABSTRACTION LPAR ATOMNAME
	  { fname = ConstAtom(yytext);
	  } SLASH NUMBER 
	  { arity = atoi(yytext);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
          } RPAR
          { Instr_Pred_Index(PUT_ABSTRACTION,GetPred(fname,arity),index1);
          }
	| TOKEN_PUT_ABSTRACTION LPAR NUMBER
	  { label = atoi(yytext);
	  } COMMA NUMBER
	  { index1 = atoi(yytext);
	  } RPAR
          { Instr_Pred_Index(PUT_ABSTRACTION,GetAbstraction(label),index1);
          }
	| TOKEN_UNIFY_VOID
	  { Instr_None(UNIFY_VOID);
	  }
	| TOKEN_UNIFY_X_VARIABLE LPAR NUMBER
	  { index1 = atoi(yytext);
	  } RPAR 
          { Instr_Index(UNIFY_X_VARIABLE,index1);
          }
	| TOKEN_UNIFY_Y_VARIABLE LPAR NUMBER
	  { index1 = atoi(yytext);
	  } RPAR 
          { Instr_Index(UNIFY_Y_VARIABLE,index1);
          }
	| TOKEN_UNIFY_X_VALUE LPAR NUMBER
	  { index1 = atoi(yytext);
	  } RPAR 
          { Instr_Index(UNIFY_X_VALUE,index1);
	  }
	| TOKEN_UNIFY_Y_VALUE LPAR NUMBER
	  { index1 = atoi(yytext);
	  } RPAR 
          { Instr_Index(UNIFY_Y_VALUE,index1);
	  }
	| TOKEN_UNIFY_CONSTANT LPAR NUMBER
	  { const_term = ConstInt(yytext);
	  } RPAR 
          { Instr_Term(UNIFY_CONSTANT,const_term);
          }
	| TOKEN_UNIFY_CONSTANT LPAR FLOAT
	  { const_term = ConstFlt(yytext);
	  } RPAR 
          { Instr_Term(UNIFY_CONSTANT,const_term);
          }
	| TOKEN_UNIFY_CONSTANT LPAR ATOMNAME
	  { const_term = ConstAtom(yytext);
	  } RPAR 
          { Instr_Term(UNIFY_CONSTANT,const_term);
          }
	| TOKEN_UNIFY_NIL
	  { Instr_None(UNIFY_NIL);
	  }
	| TOKEN_UNIFY_LIST
	  { Instr_None(UNIFY_LIST);
	  }
    	| TOKEN_UNIFY_STRUCTURE LPAR ATOMNAME
	  { fname = ConstAtom(yytext);
	  } SLASH NUMBER
	  { arity = atoi(yytext);
	  } RPAR 
          { Instr_Functor(UNIFY_STRUCTURE,ConstFunctor(fname,arity));
          }
    	| TOKEN_SWITCH_ON_CONSTANT LPAR NUMBER
	  { tablesize = atoi(yytext);
	    Instr_Size(SWITCH_ON_CONSTANT,tablesize);
	  } COMMA LHPAR constant_table RHPAR COMMA NUMBER
	  { label = atoi(yytext);
	    sort_switch_table(tablesize);
	    Next_Label(label);
	  } RPAR
    	| TOKEN_SWITCH_ON_STRUCTURE LPAR NUMBER
	  { tablesize = atoi(yytext);
	    Instr_Size(SWITCH_ON_STRUCTURE,tablesize);
	  } COMMA LHPAR functor_table RHPAR COMMA NUMBER
	  { label = atoi(yytext);
	    sort_switch_table(tablesize);
	    Next_Label(label);
	  } RPAR
	| TOKEN_SEND3
	  { Instr_None(SEND3)
	  }
	| TOKEN_SUSPEND_FLAT LPAR NUMBER
	  { index1 = atoi(yytext);
	  } COMMA NUMBER
	  { label = atoi(yytext);
	  } COMMA NUMBER
	  { size = atoi(yytext);
	    Instr_Index_Label_Size(SUSPEND_FLAT,index1,label,size);
	  } RPAR
        | FD_code_T LPAR NUMBER
          { index1 = atoi(yytext);
	    number = fd_new_label();
	    Instr_Term_Index(PUT_CONSTANT,MakeSmallNum(number),index1);
	  } COMMA fd_entry
	| LABEL LPAR NUMBER
	  { label = atoi(yytext);
	  }
	  RPAR  
	  { Label(label);
#ifdef BAM
	  }
	| m4_none(FAIL_DEC)
	| m4_index(LOAD_NIL)
	| m4_index_const(LOAD_ATOM)
	| m4_index_const(LOAD_INTEGER)
	| m4_index_index(READ_CAR)
	| m4_index_index(READ_CDR)
	| m4_indices_3(READ_ARG)
	| m4_index_index(SET_REG_REG)
	| m4_index_index(SET_REG_YVAR)
	| m4_index_index(SET_YVAR_REG)
	| m4_index_labels_5(TERM_SWITCH)
	| m4_index_constlist(ATOM_SWITCH)
	| m4_index_label_constlist(ATOM_WITH_ELSE_SWITCH)
	| m4_index_label_constlist(ATOM_WITH_ATOM_ELSE_SWITCH)
	| m4_index_label(ATOM_TYPE)
	| m4_index_label_label(ATOM_TYPE_WITH_ELSE)
	| m4_index_constlist(KNOWN_ATOM_SWITCH)
	| m4_index_constlist(KNOWN_ATOM_WITH_ATOM_ELSE_SWITCH)
	| m4_index_constlist(INTEGER_SWITCH)
	| m4_index_label_constlist(INTEGER_WITH_ELSE_SWITCH)
	| m4_index_label_constlist(INTEGER_WITH_INTEGER_ELSE_SWITCH)
	| m4_index_label(INTEGER_TYPE)
	| m4_index_label_label(INTEGER_TYPE_WITH_ELSE)
	| m4_index_constlist(KNOWN_INTEGER_SWITCH)
	| m4_index_constlist(KNOWN_INTEGER_WITH_INTEGER_ELSE_SWITCH)
	| m4_index_label_label(LIST_SWITCH)
	| m4_index_label_label(LIST_TYPE_WITH_ELSE)
	| m4_index_label(STRUCT_TYPE)
	| m4_index_label_label(STRUCT_TYPE_WITH_ELSE)
	| m4_index_functorlist(KNOWN_FUNCTOR_SWITCH)
	| m4_index_functorlist(KNOWN_FUNCTOR_WITH_FUNCTOR_ELSE_SWITCH)
	| m4_index_index_label_label(INT_COMPARE_REG_REG)
	| m4_index_const_label_label(INT_COMPARE_REG_INT)
	| m4_index_index_label_label(EQ_REG_REG)
	| m4_index_index(MATCH_REG_REG)
	| m4_index_index_offset(MATCH_REG_REG_OFF)
	| m4_index_const(MATCH_REG_ATOM)
	| m4_index_offset_const(MATCH_REG_OFF_ATOM)
	| m4_index_const(MATCH_REG_INTEGER)
	| m4_index_offset_const(MATCH_REG_OFF_INTEGER)
	| m4_index(MATCH_REG_NIL)
	| m4_index_offset(MATCH_REG_OFF_NIL)
	| m4_index_index(MATCH_REG_YVAR)
	| m4_index_index(MATCH_YVAR_YVAR)
	| m4_index_index_offset(MATCH_YVAR_REG_OFF)
	| m4_index_offset(MATCH_REG_H_LIST)
	| m4_index_offset(MATCH_YVAR_H_LIST)
	| m4_index_offset(MATCH_REG_H_STRUCT)
	| m4_index_offset(MATCH_YVAR_H_STRUCT)
	| m4_index_functor_label_offset_index(MATCH_REG_STRUCT)
	| m4_index_functor_label_level_offset_index(MATCH_REG_STRUCT_LEVEL)
	| m4_index_offset_functor_label_offset_index(MATCH_REG_OFF_STRUCT)
	| m4_index_offset_functor_label_level_offset_index(MATCH_REG_OFF_STRUCT_LEVEL)
	| m4_index_functor_label_offset_index(MATCH_YVAR_STRUCT)
	| m4_index_functor_label_level_offset_index(MATCH_YVAR_STRUCT_LEVEL)
	| m4_index_label_index(MATCH_REG_LIST_CAR)
	| m4_index_label_level_index(MATCH_REG_LIST_CAR_LEVEL)
	| m4_index_offset_label_index(MATCH_REG_OFF_LIST_CAR)
	| m4_index_offset_label_level_index(MATCH_REG_OFF_LIST_CAR_LEVEL)
	| m4_index_label_index(MATCH_YVAR_LIST_CAR)
	| m4_index_label_level_index(MATCH_YVAR_LIST_CAR_LEVEL)
	| m4_index_label_index(MATCH_REG_LIST_CDR)
	| m4_index_label_level_index(MATCH_REG_LIST_CDR_LEVEL)
	| m4_index_offset_label_index(MATCH_REG_OFF_LIST_CDR)
	| m4_index_offset_label_level_index(MATCH_REG_OFF_LIST_CDR_LEVEL)
	| m4_index_label_index(MATCH_YVAR_LIST_CDR)
	| m4_index_label_level_index(MATCH_YVAR_LIST_CDR_LEVEL)
	| m4_none(PUSH_LIST_IMM)
	| m4_offset(PUSH_LIST)
	| m4_none(PUSH_STRUCTURE_IMM)
	| m4_offset(PUSH_STRUCTURE)
	| m4_none(PUSH_NIL)
	| m4_index(PUSH_REG)
	| m4_index(PUSH_YVAR)
	| m4_none(PUSH_VOID)
	| m4_index(SET_REG_H_AND_PUSH_VOID)
	| m4_index(SET_YVAR_H_AND_PUSH_VOID)
	| m4_index_index(SET_REG_AND_YVAR_H_AND_PUSH_VOID)
	| m4_const(PUSH_ATOM)
	| m4_const(PUSH_INTEGER)
	| m4_functor(PUSH_FUNCTOR)
	| m4_index(SET_REG_H)
	| m4_index(SET_YVAR_H)
	| m4_label_index_binding(BTRY)
	| m4_label_index_binding(BTRUST)
	| m4_label_label(TEST_TRY)
	| m4_label_label(TEST_TRUST)
	| m4_label(S_TRY)
	| m4_label(S_TRUST)
	| m4_label(BACK)
	| m4_label_live(GEN_TRY)
	| m4_none(GEN_TRUST)
	| m4_pred(BEXECUTE_SIMPLE)
	| m4_pred(BEXECUTE)
	| m4_pred_live(BCALL)
	| m4_label(JUMP_GC_AND_DUMP_CONT)
	| m4_label(JUMP_GC)
	| m4_label(JUMP)
	| m4_none(BPROCEED_SIMPLE)
	| m4_none(BPROCEED)
	| m4_size(CREATE_CONT)
	| m4_level_label(TEST_LEVEL)
	| m4_label_live(CONSTRAINT_STACK_TEST)
	| m4_label(JUMP_ON_NONEMPTY_CONSTRAINT_STACK)
	| m4_none(ALIAS_CHECK)
	| m4_index_binding(ALIAS_CHECK_REG)
	| m4_index(FAIL_ON_ALIAS)
	| m4_size(CHOICE_QUIET_CUT)
	| m4_index_label_arity(SUSPEND_LONE_VAR)
	| m4_index_label_arity(BSUSPEND)
	| m4_label_arity(SUSPEND_WITHOUT_REG)
	| m4_size(CREATE_GUARD)
	| m4_label_arity(FLAT_QUIET_CUT)
	| m4_label_arity_live(FLAT_QUIET_COMMIT)
	| m4_label_arity_live(FLAT_NOISY_WAIT)
	| m4_label(SHORTCUT_QUIET_CUT)
	| m4_label(SHORTCUT_QUIET_COMMIT)
	| m4_label(SHORTCUT_NOISY_WAIT)
	| m4_none(DEEP_QUIET_CUT)
	| m4_none(DEEP_QUIET_COMMIT)
	| m4_none(DEEP_NOISY_WAIT)
	| PLABEL LPAR NUMBER
	  { label = atoi(yytext);
	  } COMMA
	  { number = atoi(yytext);	/* What to do with this? */
	    pc = (code *) WordAlign((uword)pc);
	    Label(label);
	  } RPAR
	| pseudo_term
	  { /* Maybe we should inline the pseudo_terms here? */
	  }
;

label_dest:
	LABELTAG LPAR NUMBER
	  { label = atoi(yytext);
	  } RPAR
	| TOKEN_FAIL_DEC
	  { label = 0;
	  }
;

bam_const:
	NUMBER
	  { const_term = ConstInt(yytext);
	  }
	| ATOMNAME
	  { const_term = ConstAtom(yytext);
	  }
;

bam_const_table_entry:
	bam_const COMMA label_dest
	  { BamConstTableEntry(const_term,(code)label);
	  }
;

bam_const_table:
	bam_const_table_entry
	| bam_const_table COMMA bam_const_table_entry
;


bam_functor:
	ATOMNAME
	  { fname = ConstAtom(yytext);
	  } COMMA NUMBER
	  { arity = atoi(yytext);
	  }
;

bam_functor_table_entry:
	bam_functor COMMA label_dest
	  { BamFunctorTableEntry(ConstFunctor(fname,arity),(code)label);
	  }
;

bam_functor_table:
	bam_functor_table_entry
	| bam_functor_table COMMA bam_functor_table_entry
;

bam_binding:
	CONSTANT LPAR bam_const RPAR
	  { BamBindingConst(const_term);
	  }
	| LIST LPAR label_dest RPAR
	  { BamBindingLabel(label, LABELREF_TAG_LST);
	  }
	| STRUCT LPAR label_dest RPAR
	  { BamBindingLabel(label, LABELREF_TAG_STR);
	  }
	| TYPED LPAR type_id RPAR
	  { BamBindingConst(TagPseudoTYPE(type_code));
	  }
;

type_id:
	INTEGER  { type_code = TYPED_INTEGER; }
	| ATOM   { type_code = TYPED_ATOM; }
	| STRUCT { type_code = TYPED_STRUCT; }
;

pseudo_term:
	CONSTANT LPAR bam_const RPAR
	  { BamBindingConst(const_term);
	  }
	| FUNCTOR LPAR bam_functor RPAR
	  { BamBindingFunctor(ConstFunctor(fname,arity));
	  }
	| LIST LPAR label_dest RPAR
	  { BamBindingLabel(label, LABELREF_TAG_LST);
	  }
	| STRUCT LPAR label_dest RPAR
	  { BamBindingLabel(label, LABELREF_TAG_STR);
	  }
	| REG LPAR NUMBER
	  { index1 = atoi(yytext);
	    BamBindingConst(TagPseudoREG(Bindex(index1)));
	  } RPAR
	| VOID
	  { BamBindingConst(TagPseudoREG(PSEUDO_VOID));
	  }
	| LABELED LPAR label_dest RPAR
	  { BamBindingLabel(label, LABELREF_TAG_LBL);
#endif
	  }
;

bam_integer_set:
	integer_set
	{ CodeWord(0,bitmask);
	  EndInstruction(1);
	}
;

integer_set_item:
	NUMBER
	{ index1 = atoi(yytext);
	  index1 = Bindex(index1) - bitmask_offset;
	  if  (index1 >= BITMASKBITS) {
	    FatalError("No long bitmasks yet!");
	  }
	  while (index1 >= BITMASKBITS) {
	    CodeWord(0,bitmask);
	    EndInstruction(1);
	    bitmask = 0;
	    bitmask_offset += BITMASKBITS;
	    index1 -= BITMASKBITS;
	  }
	  bitmask = (bitmask | (0x1 << index1));
	}
;
	
integer_set:
	integer_set_item
	| integer_set COMMA integer_set_item
;


constant_entry:
	LPAR ATOMNAME
	  { const_term = ConstAtom(yytext);
	  } COMMA NUMBER
	  { label = atoi(yytext);
	    ConstantTableEntry(const_term,(code)label);
	  } RPAR
	| LPAR NUMBER
	  { const_term = ConstInt(yytext);
	  } COMMA NUMBER
	  { label = atoi(yytext);
	    ConstantTableEntry(const_term,(code)label);
	  } RPAR
;

constant_table:
	constant_entry
	| constant_table COMMA constant_entry
;

functor_arity:
	SLASH NUMBER	
	  { arity = atoi(yytext);
	  } COMMA NUMBER
	  { label = atoi(yytext);
	    FunctorTableEntry(ConstFunctor(fname,arity),(code)label);
	  } RPAR
   	| COMMA NUMBER
	  { arity = atoi(yytext);	
	    features = 0;
	    hv = 0;
	    tbl = (Term*)(malloc(arity * sizeof(Term)));
	  } COMMA LHPAR feat_const_list RHPAR 
	  { if (features == 0)
	      hv = HashNameArity(Atm(fname),arity);
	    else 
	      hv = hv + (arity -features);
	  } COMMA NUMBER
	  { label = atoi(yytext);
	    FunctorTableEntry(
	       create_functor(hv,fname,features,arity,tbl),
		(code)label);		
	    free(tbl);
	  } RPAR 
;

functor_entry:
	LPAR ATOMNAME
	  { fname = ConstAtom(yytext);
	  } functor_arity
;

functor_table:
	functor_entry
	| functor_table COMMA functor_entry
;

feat_const:
	NUMBER
	  { const_term = ConstInt(yytext);
	    tbl[features++] = const_term;
	  }
	| ATOMNAME
	  { const_term = ConstAtom(yytext);
	    tbl[features++] = const_term;
	  }
;


feat_const_list_entry:
	feat_const
	  { build_hashvalue(const_term,0,&hv);
	  }
;

feat_const_list:
	feat_const_list_entry
	| feat_const_list COMMA feat_const_list
;


fd_entry:
        RPAR
          { fd_add_instr(FD_HALT); }
        | fd_instr fd_entry
;

fd_instr:
        NUMBER
          m4_fd_const(atoi(yytext))
        | FD_const_T
          m4_fd_instr(FD_CONST)
	| FD_element_x_T
	  m4_fd_instr(FD_ELEMENT_X)
	| FD_element_i_T
	  m4_fd_instr(FD_ELEMENT_I)
        | FD_val_T
          m4_fd_instr(FD_VAL)
        | FD_val_0_T
          m4_fd_instr(FD_VAL_0)
        | FD_val_1_T
          m4_fd_instr(FD_VAL_1)
        | FD_val_2_T
          m4_fd_instr(FD_VAL_2)
        | FD_max_elem_T
          m4_fd_instr(FD_MAXELEM)
        | FD_add_T
          m4_fd_instr(FD_ADD)
        | FD_sub_T
          m4_fd_instr(FD_SUB)
        | FD_mult_T
          m4_fd_instr(FD_MULT)
        | FD_divd_T
          m4_fd_instr(FD_DIVD)
        | FD_divu_T
          m4_fd_instr(FD_DIVU)
        | FD_mod_T
          m4_fd_instr(FD_MOD)
        | FD_min_T
          m4_fd_instr(FD_MIN)
        | FD_max_T
          m4_fd_instr(FD_MAX)
        | FD_dom_min_T
          m4_fd_instr(FD_DOMMIN)
        | FD_dom_min_0_T
          m4_fd_instr(FD_DOMMIN_0)
        | FD_dom_min_1_T
          m4_fd_instr(FD_DOMMIN_1)
        | FD_dom_min_2_T
          m4_fd_instr(FD_DOMMIN_2)
        | FD_dom_max_T
          m4_fd_instr(FD_DOMMAX)
        | FD_dom_max_0_T
          m4_fd_instr(FD_DOMMAX_0)
        | FD_dom_max_1_T
          m4_fd_instr(FD_DOMMAX_1)
        | FD_dom_max_2_T
          m4_fd_instr(FD_DOMMAX_2)
        | FD_dom_T
          m4_fd_instr(FD_DOM)
        | FD_dom_0_T
          m4_fd_instr(FD_DOM_0)
        | FD_dom_1_T
          m4_fd_instr(FD_DOM_1)
        | FD_dom_2_T
          m4_fd_instr(FD_DOM_2)
        | FD_range_T
          m4_fd_instr(FD_RANGE)
        | FD_outer_range_T
          m4_fd_instr(FD_OUTER_RANGE)
        | FD_setadd_T
          m4_fd_instr(FD_SETADD)
        | FD_setsub_T
          m4_fd_instr(FD_SETSUB)
        | FD_setmod_T
          m4_fd_instr(FD_SETMOD)
        | FD_compl_T
          m4_fd_instr(FD_COMPL)
        | FD_union_T
          m4_fd_instr(FD_UNION)
        | FD_inter_T
          m4_fd_instr(FD_INTER)
	| FD_check_T
	  { 
            fd_add_instr(FD_CHECK);
	    fd_push_check_label();
	  }
	| FD_label_T
	  {
	    fd_pop_check_label();
	  }
;

%%
static int yyerror(s)
	char *s	;
{
    fprintf(stderr, "%s\n", s);
    return 1;
}

