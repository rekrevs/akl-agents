# Thesis Part 07

## A COMPUTATION MODEL (continued)

χ[G] denotes the expression obtained by substituting a goal G for λ in χ. χ may be referred to as the context of (this occurrence of) the goal G in χ[G]. Correspondingly, the expression χ[χ'] denotes the context obtained by substituting a context χ' for λ in χ. When λ occurs in a context χ of the form χ′[**and**(R, λ, S)^σ_V] or χ′[**or**(R, λ, S)], χ[] denotes the expression obtained by deleting λ.

The *environment* of a context, env(χ), is the conjunction of all constraints in all and-boxes surrounding the hole of χ.

• env(λ) = **true**
• env(**and**(R, χ, S)^σ_V) = env(χ) ∧ σ
• env(**or**(R, χ, S)) = env(χ)
• env(**choice**(R, (χ % A), S)) = env(χ)
• env(**aggregate**(u, χ, v)) = env(χ)

By the environment of an occurrence of a goal G in another goal χ[G], we mean the environment of χ.

A goal G is a *subgoal* of any goal of the form χ[G].

### 4.4 GOAL TRANSITIONS

An *AKL goal transition system* w.r.t. a given program is a structure 〈∆, ⇒〉, where ∆ is the set of expressions generated by 〈goal〉, and ⇒ ⊆ ∆ × M × C × ∆ is a labelled transition relation, where M is the mode (one of D or N) and C is the set of contexts.

Read

G ⇒^m_χ G'

as saying that there is a transition from G to G' in mode m with context χ. The letters D and N stand for *determinate* and *nondeterminate* mode, respectively.

The rest of this section describes the rules defining the transition relation.

First, the *subgoal* rule

```
     G ⇒^m_{χ'[χ]} G'
    ─────────────────
    χ[G] ⇒^m_χ' χ[G']
```

derives transitions of goals depending on transitions that can be made by the components of the goals.

#### 4.4.1 Basic Statements

The *constraint atom* rule

**and**(R, A, S)^σ_V ⇒^D_χ **and**(R, S)^{A∧σ}_V

moves a constraint atom A to the constraint part of the and-box, thereby making it part of the constraint environment of the goals in the box.

The *program atom* rule

A ⇒^D_χ B

unfolds a program atom A using its definition A := B, where the arguments of A are substituted for the formal parameters, and bound variables in B are renamed as appropriate to avoid conflicts with the parameters of A.

The *composition* rule

**and**(R, (A, B), S)^σ_V ⇒^D_χ **and**(R, A, B, S)^σ_V

flattens compositions, making their components parts of the enclosing and-box.

The *hiding* rule

**and**(R, (U : A), S)^σ_W ⇒^D_χ **and**(R, B, S)^σ_{V∪W}

introduces new variables. The variables of U in A are replaced by the variables in the set V, giving the new statement B. The set V is chosen to be disjoint from W, from all sets of local variables in R, S, and χ, and from the set of variables bound in A.

The *choice* rule

(U1 : A1 % B1 ; … ; Un : An % Bn) ⇒^D_χ

**choice**(**and**(A′_1)^**true**_{V1} % B′_1, …, **and**(A′_n)^**true**_{Vn} % B′_n)

starts local computations in guards. The local variables Ui in Ai and Bi are replaced by the variables in the set Vi, giving new statements A′_i and B′_i. The sets Vi are chosen to be disjoint from each other, from all other sets of local variables in χ, and from the set of variables bound in Ai or Bi.

#### 4.4.2 Promotion

The *promotion* rule

**and**(R, **choice**(σV % B), S)^θ_W ⇒^D_χ **and**(R, B, S)^{σ∧θ}_{V∪W}

promotes a single remaining guarded goal with a solved guard and-box. If % is '→' or '|' it is required that σ is quiet with respect to θ ∧ env(χ) and V.

#### 4.4.3 Pruning

The *condition* rule

**choice**(R, σV → B, S) ⇒^D_χ **choice**(R, σV → B)

may be applied if S is non-empty and σ is quiet with respect to env(χ) and V.

The *commit* rule

**choice**(R, σV | B, S) ⇒^D_χ **choice**(σV | B)

may be applied if at least one of R or S is non-empty and σ is quiet with respect to env(χ) and V.

#### 4.4.4 Failure

The *environment failure* rule

**and**(R)^σ_V ⇒^D_χ **fail**

fails an and-box if σ and env(χ) are incompatible.

The *goal failure* rule

**and**(R, **choice**(), S)^σ_V ⇒^D_χ **fail**

fails an and-box if it contains an empty choice-box.

The *guard failure* rule

**choice**(R, **fail** % B, S) ⇒^D_χ **choice**(R, S)

removes a failed guarded goal.

#### 4.4.5 Nondeterminism

The *choice splitting* rule

**and**(S1, **choice**(T1, T2), S2)^σ_V ⇒^N_χ

**or**( **and**(S1, **choice**(T1), S2)^σ_V ,
      **and**(S1, **choice**(T2), S2)^σ_V )

distributes nondeterminism in an inner nondeterminate choice-box over an and-box, creating alternatives in an outer box. The following two conditions must be satisfied.

• T1 must be a single guarded goal of the form (θW ? A) and T2 must be non-empty. Choice splitting is said to be performed *with respect to* T1, and in a goal matching the left hand side of the rule, T1 is called a *candidate* for choice splitting.

• The rewritten and-box must be a subgoal of a stable goal. The notion of stability is explained in Section 4.5.

The *guard distribution* rule

**choice**(R, **or**(G, S) % B, T) ⇒^D_χ **choice**(R, G % B, **or**(S) % B, T)

distributes alternatives in a guard over a guarded goal, making the or-branches different guarded goals in the containing choice-box.

#### 4.4.6 Aggregates

The *aggregate* rule

**aggregate**(u, A, v) ⇒^D_χ **aggregate**(w, **or**(**and**(B)^**true**_{w} ), v)

introduces an aggregate-box. The variable u in A is replaced with a variable w, giving the new statement B. The variable w is chosen to not occur in any set of local variables in the context χ, nor in the set of variables bound in A.

In the following, the expressions *unit(v)* and *collect(u', v', v)* stand for statements with one and three free variables, respectively. Nothing precludes having at the same time several different types of aggregates with different associated unit and collect statements, but for simplicity we restrict this exposition to one type of aggregate.

We may rewrite aggregate-boxes by the *unit* rule

**aggregate**(u, **fail**, v) ⇒^D_χ *unit(v)*

and by the *collect* rule

**and**(R1, **aggregate**(u, **or**(S1, σV, S2), v), R2)^θ_W ⇒^D_χ

**and**(R1, **aggregate**(u, **or**(S1, S2), v'), *collect(u', v', v)*, R2)^{σ′∧θ}_{V′∪W}

if σ is quiet w.r.t. θ∧env(χ) and V. The local variables V in σ are replaced by the variables in the set V′, giving σ'. The set V' is chosen to be disjoint from W and all sets of local variables in R1, R2, and χ. In particular, the variable u is replaced by u'. If the aggregate is ordered it is also required that S1 is empty.

The *or-flattening* rule

**or**(R, **or**(S), T) ⇒^D_χ **or**(R, S, T)

unnests nested or-boxes, making the alternatives available for the collect rule.

#### 4.4.7 Constraint Simplification

Simplification of constraints is not an essential part of the AKL model, but can be expressed as follows. With a constraint theory may be associated *constraint simplification rules* of the general form

**and**(R)^σ_U ⇒^D_χ **and**(R)^θ_V

that replace σ and U with θ and V. The set V contains all variables in U that occur in θ or R, and new variables that are in θ, but not in R, U or χ. The rules must satisfy the following condition

TC = env(χ) ⊃ (∃Wσ ≡ ∃Wθ)

where W contains all variables in U and V not occurring in R, and they may not give rise to infinite sequences of simplifying transitions.

Simplification rules can be used to justify simplifications performed in an implementation, e.g., during constraint solving and garbage collection.

For the constraint system of rational trees, we have already, informally, introduced simplification by unification. A more precise description follows, for use in Chapter 5.

Simplification is relative, in that it is performed with respect to a given simplified constraint θ [Aït-Kaci, Podelski, and Smolka 1992]. As before, we assume that θ has substitution form, in which all equations of the form u = v together form an acyclic relation over the variables. If we regard this relation over the variables as a partial order, the sets of variables known to be equal have unique maximal elements. Given a variable v, we refer to this as deref(v, θ). Below, u′ is deref(u, θ) and v′ is deref(v, θ).

We assume that σ∧**true** and **true**∧σ and σ∧**false** and **false**∧σ are always simplified to σ and **false**, respectively. Note below that if a constraint σ is simplified to σ′ relative to θ, then θ∧σ′ has the acyclic substitution form required above.

A constraint of the form u = f(v1, …, vk) is simplified to **false** if u′ is bound to a constructor expression with different constructors, to the simplified form of u1 = v1 ∧ … ∧ uk = vk, if it has the same constructor and arguments ui, and otherwise to u′ = f(v1, …, vk).

A constraint u = v is simplified to **true** if u′ is equal to v′, to **false** if u′ and v′ are bound to constructor expressions with different constructors, to the simplified form of u1 = v1 ∧ … ∧ uk = vk for their arguments ui and vi, if they have the same constructor, to u′ = v′ if u′ is not bound, and otherwise to v′ = u′.

A constraint σ1∧σ2 is simplified to σ′_1∧σ′_2, where σ1 is simplified to σ′_1 relative to θ and σ2 is simplified to σ′_2 relative to θ∧σ′_1.

The above can be used for a rule that simplifies a constraint that has just been added by the constraint atom rule (relative to the conjunction of the remaining local store and the environment), and for a rule that simplifies an entire local store when constraints have been added to stores in its environment.

Simplification corresponding to garbage collection involves partitioning local stores σ in substitution form into two parts σ1 and σ2, where σ2 binds variables in W that do not occur in σ1. Clearly, ∃Wσ is equivalent to ∃Wσ1, and σ2 can be garbage collected.

### 4.5 NONDETERMINISM AND STABILITY

Choice splitting potentially duplicates work. Therefore, it is delayed until it is necessary for the computation to proceed. Let us refer to the and-box which is to be rewritten by choice splitting as GN and to its context as χN. Conditions that formalise the above "necessity" will be placed on a goal G and its context χ, for which

χN = χ[χ'] and G = χ'[GN]

A first condition is to require that no determinate transitions are possible on G in χ. We say that a goal G is *quiescent* in χ if

¬∃G'(G ⇒^D_χ G')

However, future transitions in the context of a goal may produce constraints that either entail or are incompatible with constraints within the goal. Therefore, not only should it be required that no determinate transitions are applicable, but also that determinate transitions cannot become applicable as a result of further transitions in the context of the goal. Unfortunately, as stated, this condition is undecidable, and cannot be used for programming purposes.

Instead, we say that a goal is *stable* in a given context if it is quiescent, and remains so even if arbitrary constraints, compatible with the environment, are added to the and-boxes in the context of the goal. We thereby avoid reasoning about the constraints that may be produced by future computations, and need only consider the relationship between constraints in the goal and its environment. It still depends on the constraint theory whether this condition is computationally tractable, but it is well-behaved for rational trees.

Formally, a goal G is stable in context χ if it is quiescent and

∀χ'∀τ (G=χ'[] ⊃ [TC = env(χ) ∧ τ ⊃ ∃V env(χ')])

∀χ'∀τ ∀σ∀U (G=χ'[σU] ⊃ [TC = env(χ) ∧ τ ⊃ ∃V (env(χ') ∧ ¬∃Uσ)])

where V is the set of variables local to and-boxes in G.

Note that the notation χ[] will give us contexts that include solved and-boxes. The first condition states that environment failure will not become applicable. The second condition states that no solved and-box will become quiet. This is stronger than required, but can be made precise by only considering solved and-boxes for which quietness can cause further transitions. Even stronger, but probably more useful, conditions are

∀χ' (G=χ'[] ⊃ [TC = env(χ) ⊃ ∃V env(χ')])

∀χ'∀σ∀U (G=χ'[σU] ⊃ [TC = env(χ) ⊃ ∃V (env(χ') ∧ ¬∃Uσ)])

For the constraint theory of rational trees, the first of these conditions implies the second and is also equivalent with the above formulation [Franzén 1994]. If relative simplification is performed as suggested, a "constructive" formulation of this condition is that G should not contain equations of the form v = f(…) or u = v, where u and v are not in V.

Additional conditions may, and should, be imposed on the choice splitting rule, for example that it must be applied with respect to the leftmost candidate in an innermost stable box. However, it is not the intention that AKL should be based on a single such rule. Instead, it should be chosen for the given program. The topic of how to make this selection (e.g., using the concept of engines) is outside the scope of this dissertation, where we assume that a leftmost candidate be chosen.

### 4.6 CONFIGURATIONS AND COMPUTATIONS

Two sets of local variables in a goal *interfere* if their intersection is non-empty and either they occur in different goals in an and-box, or one occurs in the and-box of the other. A goal is *well-formed* if no sets of variables interfere.

A well-formed global goal is a *configuration* iff all variables occurring free anywhere in the goal occur in the set of local variables of some and-box in the goal. The letter γ stands for configurations.

OBSERVATION. *Transitions take well-formed goals to well-formed goals, and configurations to configurations.*

That goals are taken to goals is verified by inspection of the rules.

Variables are introduced in the hiding, choice, aggregate, and constraint simplification rules, and then as non-interfering sets of local variables.

Choice splitting duplicates sets of local variables, but not in a way that puts them in different goals in an and-box.

Promotion and the collect rule move variables between sets.

The set of local variables in the and-box promoted by the promotion rule does not interfere with the sets in the and-box to which it is promoted, since they are in different goals in this and-box, nor with the sets in any and-box containing it. Thus, the union will not interfere with any other set.

The set of local variables in the set promoted by the collect rule is renamed to avoid conflicts.

Other rules do not add or move variables. ♦

The *AKL computation model* is a structure 〈∆, →〉, where ∆ is the set of configurations, and → ⊆ ∆ × ∆ is a transition relation, defined as the subset of goal transitions that are transitions on configurations.

γ → γ' ≡ γ ⇒^m_λ γ'

A *derivation* is a finite or infinite transition sequence

γ0 → γ1 → γ2 → …

A configuration γ which satisfies ¬∃γ'. γ → γ' is *terminal*.

*Initial configurations* are of the form

**or**(**and**(A)^**true**_V )

where V is the set of variables occurring free in the statement A. The statement A is also referred to as the *query*.

*Final configurations* are of the form

**or**(**and**()^{σ1}_{V1}, …, **and**()^{σn}_{Vn})

in which all and-boxes are solved. A terminal configuration that is not final is *stuck*.

A *computation* is a derivation beginning with an initial configuration and, if finite, ending with a terminal configuration.

The sequence of and-boxes in a final configuration may be empty, in which case we talk of a *failed computation*. Otherwise, the constraints σi are referred to as the *answers* of the computation (also referred to as the answers to the query).

### 4.7 POSSIBLE EXTENSIONS

The computation model presented can be extended in many directions. By adding new guard operators, corresponding to new forms of choice statements, expressiveness is added to AKL with a minimum of effort, for programmers and implementors alike.

In the following, two variants of conditional choice are presented. The first, the logical condition, admits a cleaner logical interpretation. The second, cut, is unclean, but highly useful for executing Prolog programs in the AKL environment.

#### 4.7.1 Logical Conditions

Due to the guard distribution rule, the condition operator of AKL prunes not only other clauses in the original choice, but also alternative solutions of the guards. This has advantages, e.g., for a metainterpreter and for the implementation, but an operator which does not is subject to a less restrictive logical interpretation, as shown by Franzén [1994].

We introduce the logical condition operator →L (called *soft cut* by Franzén) to which the guard distribution rule does not apply. To this operator corresponds a *logical conditional choice* statement.

We also need the notion of *or-component*, which is defined as follows. (1) If G is an and-box, G is an or-component of G. (2) If G is an or-component of G', then G is an or-component of **or**(R, G', S).

The *logical condition* rule

**choice**(G →L B, S) ⇒^D_χ **choice**(G ? B)

may be applied if σV is an or-component of G and σ is quiet with respect to env(χ) and V.

We may also add a rule

**choice**(R, G →L B, S) ⇒^D_χ **choice**(R, G →L B)

which prunes alternatives more eagerly if the above conditions hold and R and S are both non-empty.

#### 4.7.2 Cut

Prolog provides the cut operation, which is noisy in the sense that pruning is performed without a quietness condition. In Prolog, synchronisation is given by the sequential execution order. Therefore, the state in which cut is applied is well-defined. (However, the noisiness of cut creates problems when freeze and similar coroutining constructs are added, as in the SICStus Prolog implementation [Carlsson et al 1993].)

In AKL, an operation very similar to cut can be introduced by adding a noisy form of the condition operator. This operation becomes very unpredictable unless some other form of synchronisation is added. The solution is to regard noisy pruning as a form of nondeterminate action, which is allowed in the same circumstances as choice splitting, i.e., in stable goals.

The syntax is augmented with a new guard operator, let us say '!', to which also corresponds a *cut choice* statement. The existing rules will work appropriately together with the following.

The *noisy cut* rule

**choice**(R, σV ! B, S) ⇒^N_χ **choice**(R, σV ! B)

may be applied within a stable goal if S is non-empty, and the *quiet cut* rule

**choice**(R, σV ! B, S) ⇒^D_χ **choice**(R, CV ! B)

may be applied if S is non-empty and σ is quiet with respect to env(χ) and V.

The cut operation is highly useful when translating Prolog into AKL, and this application is discussed in Chapter 8.

### 4.8 FORMAL ASPECTS

Franzén [1994] presents soundness and completeness results for a logical interpretation of a subset of AKL, and a confluence result for a similar subset of AKL with certain restrictions on the choice splitting rule. These results are summarised here, partly informally, for the completeness of this exposition. Formal definitions and proofs are found in [Franzén 1994].

#### 4.8.1 Logical Interpretation

Definitions and statements are interpreted (by *) as

(A := B)* ⇒ A ≡ B*
A* ⇒ A (atom A)
(A, B)* ⇒ A* ∧ B*
(V : A)* ⇒ ∃V A*
( V1 : A1 % B1 ; … ; Vn : An % Bn )* ⇒
    ∃V1 (A1* ∧ B1*) ∨ … ∨ ∃Vn (An* ∧ Bn*)  (% ∈ {|, ?})
( V1 : A1 → B1 ; … ; Vn : An → Bn )* ⇒
    ∃V1 (A1* ∧ B1*) ∨ …
        ∨ ((¬∃V1 A1*) ∧ … ∧ (¬∃Vn-1 An-1*) ∧ ∃Vn (An* ∧ Bn*))

and goals, correspondingly, as

**fail*** ⇒ **false**
(**fail** % B)* ⇒ **false**
(**or**(G1, …, Gn) % B)* ⇒ (G1 % B)* ∨ … ∨ (Gn % B)*  (% ∈ {|, ?})
(**or**(G1, …, Gn) → B)* ⇒
    (G1 → B)* ∨ … ∨ (¬G1* ∧ … ∧ ¬Gn-1* ∧ (Gn → B)*)
**or**(G1, …, Gn)* ⇒ G1* ∨ … ∨ Gn*
(**and**(G1, …, Gn)^σ_V % B)* ⇒
    ∃(V\U) (σ ∧ G1* ∧ … ∧ Gn* ∧ B*)
(**and**(G1, …, Gn)^σ_V)* ⇒ ∃(V\U) (σ ∧ G1* ∧ … ∧ Gn*)
**choice**(G1, …, Gn)* ⇒ G1* ∨ … ∨ Gn*  (% ∈ {|, ?})
**choice**(G1 → B1, …, Gn → Bn)* ⇒
    (G1 → B1)* ∨ … ∨ (¬G1* ∧ … ∧ ¬Gn-1* ∧ (Gn → Bn)*))

where U is the set of variables that were given as local variables to the corresponding initial configuration. This technicality is necessary for the notion of logical computation introduced below.

The logical interpretation of a given program Σ is a set of formulas Σ*, which is referred to as the *completion* of Σ. In the following, T stands for the union of Σ* and TC, the given theory of constraints.

#### 4.8.2 Soundness

A computation γ0 → γ1 → … is *logical* if T = γi* ≡ γi+1* for every non-final i. A program is logical if every computation from that program is logical. The following properties clearly hold for logical programs.

PROPOSITION (soundness of answers).
*If σ is an answer to a query A then* T = σ ⊃ A*.

PROPOSITION (soundness of failure).
*If there is a computation leading from a query A (with free variables V) to a final configuration*

**or**(**and**()^{σ1}_{V1}, …, **and**()^{σn}_{Vn})

*then* T = A* ⊃ ∃W1σ1 ∨ … ∨ ∃Wnσn, *where* Wi *is* Vi\V.

*In particular, if n = 0 then* T = ¬A*.

AKL programs are logical if all conditional choice statements have *indifferent guards*, roughly meaning that if there are multiple solutions of a guard the result of the choice is the same for all, and if all committed choice statements have *authoritative guards*, roughly meaning that if more than one clause is applicable, then the choice between clauses (and solution within guards) will not matter for the result of the choice. For logical conditional choice, guards need not be indifferent.

One trivial case of indifference is that in which guards do not have multiple solutions simply because nondeterminate choice is not used. Another simple case of indifference is that in which no local variables are shared between the guard and the body. As a consequence, negation as failure is sound in AKL, since there are no variables that can be shared.

not_p(X) := ( p(X) → **fail** ; **true** )

Together, these two cases cover a majority of the conditional choice statements which are written in practice.

The notion of authoritative guards is less useful. It covers some important cases, such as the use of commit for constraint propagation, where clauses have the same, or overlapping, logical content, exemplified by

and(X, Y, Z) :=
  ( X = 0 | Z = 0, ( Y = 0 ; Y = 1 )
  ; Y = 0 | Z = 0, ( Y = 0 ; Y = 1 )
  ; X = 1, Y = 1 | Z = 1
  ; Z = 0, X = 1 | Y = 0
  ; Z = 0, Y = 1 | X = 0
  ; Z = 1 | X = 1, Y = 1 ).

and also the following more complete form of negation.

not_p(X) := ( ( p(X) | **true** ) → **fail** ; **true** )

The use of commit in a program such as merge, where the choice gives rise to logically distinct solutions, is not authoritative.

#### 4.8.3 Completeness

A computation is *normal* if all guard computations terminate. A computation is *or-fair* if all non-terminal or-components are eventually rewritten.

PROPOSITION (completeness).
*Let Σ be a program using only atoms, composition, hiding, and nondeterminate choice. If Π is an or-fair normal computation starting with a query A, and*

Σ* = θ ⊃ A*

*then some configuration in Π has an or-component* σV *such that*

TC = θ ⊃ ∃V\Uσ

*where U are the free variables in A.*

#### 4.8.4 Confluence

Two computations

Π: γ0 → γ1 → γ2 → …
Π′: γ0 → γ′1 → γ′2 → …

starting from the same initial goal γ0, are *confluent* if for every γi there is a γ′j such that γi = γ′j or γi →* γ′j (where →* is the transitive closure of →), and conversely with Π and Π′ interchanged.

Informally, a *complete computation* is either finite, or no subgoal appears in the course of the computation such that (1) the subgoal survives unchanged throughout the computation, and (2) for infinitely many configurations in the computation, some rule is applicable to the subgoal.

PROPOSITION (confluence).
*If computations are complete, the program contains no commit procedures or aggregates (and the applicability of choice splitting is somewhat further restricted to avoid interference between two possible such steps, where one step prevents the stability of another), then any two computations are confluent.*

One condition on choice splitting that guarantees confluence is to select the leftmost candidate in an innermost stable box.

### 4.9 RELATED WORK

Several more or less closely related computation models exist. The early models have in common that they are based on the constraint theory of trees and unification in an operational manner, which cannot easily be generalised to arbitrary constraints. Notions such as quietness and stability can then not be used for synchronisation. Instead more ad hoc notions are used that are related to bindings on individual variables. The models that do provide don't know nondeterminism do not provide aggregates.

Gregory [1987] describes a computation model for Kernel PARLOG, which is reminiscent of the computation model of AKL in that it models a language with deep guards using rewrite rules on an AND/OR tree. It does not deal with don't know nondeterminism nor with general constraints. On the other hand it provides sequential composition. A detailed comparison with PARLOG at the language level is given in Section 8.2.

Saraswat [1987a; 1987b; 1987c] presents a computation model for the to AKL closely related language CP[↓,|,&,;]. CP provides deep guards as well as don't know nondeterminism via the don't know guard operator '&'. It is not based on general constraints. Synchronisation is expressed with '↓' annotations on terms, which say that such terms may not be bound to external variables. Commit is not quiet, but relies on '↓' for synchronisation. Don't know nondeterminism is not synchronised, as with stability, but may happen at any time. There are no aggregates. The nature of '↓' makes a detailed comparison with AKL difficult, but AKL restricted to flat guards can be regarded as a subset of the more recent cc framework of Saraswat [1989], and their relation is discussed in Section 8.4.

Warren [1989] considers a computation model called the Extended Andorra Model (EAM), which is based on rewrite rules on a tree of and- and or-boxes closely related to those of AKL. The EAM is not based on constraints and does not encompass aggregates. It is mainly intended for parallel execution of full Prolog. This is clearly visible in its control scheme, which is based on a sequential flow of data from the left to the right in a configuration. The leftmost occurrence of a variable is regarded as a producer. Bindings attempted at other occurrences suspend. The EAM and AKL models evolved in the ESPRIT project PEPMA (EP 2471).

Haridi and Janson [1990] describes the Kernel Andorra Prolog (KAP) framework, which is an immediate antecedent of AKL. The main difference is that KAP is not based on quietness for the pruning guards. A similar effect is achieved by synchronising constraint operations, which move a constraint to the constraint store only if certain conditions hold on its relation to its environment w.r.t. variables at different levels. These operations destroy confluence and were abandoned in AKL. Atomicity of constraint operations, pruning, and promotion was also a concern. In practice, such concepts do not carry over easily to constraint systems other than trees, and are not present in AKL.

Smolka [1994] presents a calculus for the deep-guard higher-order concurrent constraint language Oz. It is based on feature constraints, which are internalised by relative simplification rules. Constraints do not form environments, but "permeate" through the computation state by congruence rules. Synchronisation is via quietness and determinism, as in AKL. Oz does not use fixed form constructions such as boxes, but relies on congruence rules to provide multiple views that are exploited in the transition rules. A main difference is that Oz is higher-order. Programs do not exist outside the computation state, but are available on blackboards, which may be regarded as associated with and-boxes (in AKL terminology) in much the same way as constraint stores. A recent extension offers don't know nondeterminism in a manner that exploits the higher-orderness of the language [Schulte and Smolka 1994]. Oz is compared with AKL in more pragmatic terms in Section 8.5.
