# Thesis Part 17

## PORTS FOR OBJECTS (continued)

```
send(Request, TupleSpace) :=
  hash(Request, Index),
  arg(Index, TupleSpace, Port),
  send(Request, Port).
```

To each port in the hash table is connected a tuple space server of the kind presented above.

#### 7.7.7 Erlang

Erlang is a concurrent functional programming language designed for prototyping and implementing reliable (distributed) real time systems [Armstrong, Williams, and Virding 1991; 1993]. Although not restricted to this area, Erlang is mainly intended for telephony applications. That functional programming as in the functional component of Erlang is provided by AKL is illustrated in Section 3.4.1. Here it is argued that the process component, including its error handling capabilities, can be expressed in AKL.

Erlang is probably less well known than the other languages in this chapter. Therefore, its essential features will be summarised before the comparison.

Processes are expressed in a sequential first-order functional programming language. The functional component is augmented with side effect operations such as creation of processes and message passing. The operation which creates a process returns a process identifier (*pid*).

*Pid* = spawn(*Module*, *Function*, *Arguments*)

A process may acquire its own pid using the self() operation. Pids may be given *global names*, a feature not further discussed here. Messages are sent to a pid with the *Pid* ! *Message* operation. Messages are stored in the *mail-box* of a process, from which they may be retrieved at a later time using the *receive* operation

```
receive
  Pattern [when Guard] -> … ;
  …
  [after Time -> …]
end
```

If a message matching a pattern (and satisfying the guard condition) is found among the messages in the mail-box, it is removed. The pattern is a constructor expression with local variables which are bound to the corresponding components in the message. The last clause may specify a *time-out*, which will not be further discussed here.

For the purpose of error-handling, processes may be *linked*. [It is assumed that these links are unidirectional, i.e., *from* one process *to* another process.] Links may be added, deleted, and, in particular, associated with new processes atomically at the moment of spawning (in which case a link is established from the new process to the old process).

```
link(Pid)                                    (Pid to self)
link(Pid1, Pid2)                             (Pid2 to Pid1)
unlink(Pid)
unlink(Pid1, Pid2)
Pid = spawn_link(Module, Function, Arguments) (Pid to self)
```

If an error occurs in a process, exit-signals are automatically sent to the processes it is linked to. A process which receives an exit-signal will by default also exit. This can be overridden, whereby signals are trapped, and converted to ordinary messages, which can be received in the usual fashion. A process may simulate an exit, and may also force another process to exit.

```
process_flag(trap_exit, [true/false])    (trap exit-signals)
receive {'EXIT', From, Message} -> … ; end
exit(Reason)
exit(Pid, Reason)                        (force exit of Pid)
```

Signals may also be caught and generated by *catch* and *throw* operations, which are not further discussed here.

We now proceed to express the above in AKL using ports. To simplify the presentation, the following restrictions are made:

• Communication in Erlang is somewhat similar to *tuple space* communication in Linda, which was discussed in the previous section, and does also provide for time-outs. This aspect is ignored here. Communication is sent on a plain port, and served in a first-come first-served manner.

• Erlang distinguishes between *signals* and *messages*. This distinction is not made here, where both are regarded as messages, as when trapping of exit signals is turned on in Erlang.

• In Erlang, processes notify linked processes also about successful completion. This can be detected using short-circuiting, as in Section 7.7.1, and is not deemed important here.

An Erlang process identifier is mapped to an AKL port. Erlang processes have coarser granularity than AKL processes; to each Erlang process corresponds a *group* of AKL processes, performing the computations corresponding to the (sequential) functional component of Erlang. It is assumed that the definitions of these processes are written in the flat committed choice subset of AKL, where the guards may only contain simple tests.

The processes in a group share a pair p(V, P), the first component of which is either unconstrained or equal to the constant "exit", and the second component of which is a port. It is assumed that all atoms, except the simple tests in guards, are supplied with this pair in an extra argument. If an error occurs in a primitive operation, a message of the form exit(*Reason*) is sent on the port in the pair, otherwise no action is taken. If the first component is equal to "exit", an operation may terminate with no further action.

All choice statements in the definitions of processes in a group should have an extra case which examines the state of the first component of the pair, terminating if it is equal to "exit".

```
p(…, F) :- …
…
p(…, p(exit,_)) :- | true.
```

A process group is created as follows.

```
group(Args, L, P) :=
  descriptor(P, Args, D),
  error_handler(L, P, S, F),
  processes(S, Args, F, P).
```

The *descriptor* agent forms a suitable descriptor of the current process to be sent to linked processes in the event of a failure, and may be defined in any appropriate manner. The definitions of the following agents are generic, and can be shared between all process groups.

```
error_handler(L, P, S, F) :=
  open_port(P, S),
  open_port(FP, Cs),
  F = p(_,FP),
  distribute(S, FP, Ms),
  linker(Cs, D, L).
```

The *distribute* agent filters out the *special* messages to the group, concerning linking and exiting, which are sent to the linker.

```
distribute([], C, Ms) :-
  → Ms = [].
distribute([special(C)|S], FP, Ms) :-
  → send(C, FP, FP1),
    distribute(S, FP1, Ms).
distribute([M|S], FP, Ms) :-
  → Ms = [M|Ms1],
    distribute(S, FP, Ms1).
```

The *linker* agent holds the list of pids (ports) of processes which the group is linked to, and an initial list (L) may be provided at the time of creation of the group, as in the spawn_link operation. It informs linked processes in the event of forced exit or failure.

```
linker([link(P1)|Cs], D, L) :-
  → linker(Cs, D, [P1|L]).
linker([unlink(P1)|Cs], D, L) :-
  → delete(P1, L, L1),
    linker(Cs, D, L1).
linker([exit(R)|Cs], D, L) :-
  → F = p(exit,_),
    send_ports(L, exit(D, R)).
```

```
send_ports([], _) :-
  → true.
send_ports([P|Ps], M) :-
  → send(M, P),
    send_ports(Ps, M).
```

The *processes* agent creates the group of processes that perform the actual computation, receive and send messages, etc.

As demonstrated above, the degree of safety achieved with Erlang error handling can also be achieved in AKL, but at the cost of slightly more verbose programs: some process group set-up, and an extra argument to all atoms. Syntactic sugar could easily remedy this, if such capabilities warrant special treatment.

The computational overhead is the time to set up the error handler and the storage it occupies, the filtering of messages, the passing around of the extra argument, and (occasionally) suspending on the extra argument.

As it is currently defined, the error_handler will remain also when computation in the corresponding process group has terminated. It will terminate only when there are no more references to the port of the group.

### 7.8 DISCUSSION

The notion of ports provides AKL with a model of mutable data, which is necessary for effective object-oriented programming and effective parallel programming. Ports can serve as an efficient interface to foreign objects, e.g., objects imported from C++. They also support a variety of process communication schemes. Thus, ports reinforce otherwise weak aspects of AKL, and can also be introduced and used for the same purpose in other concurrent (constraint) logic programming languages.

Other useful communication mechanisms are conceivable that do not fall into the category discussed here. For example, the *constraint communication* scheme of Oz [Smolka, Henz, and Würtz 1993], has similar expressive power (except for automatic closing), but has to be supported by the additional concept of a blackboard. It can, however, be emulated by ports, using code equivalent to that for M-fields in Id (Section 7.7.4).
